/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package sniffer;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.DefaultListModel;
import org.jnetpcap.Pcap;
import org.jnetpcap.PcapAddr;
import org.jnetpcap.PcapBpfProgram;
import org.jnetpcap.PcapIf;
import org.jnetpcap.PcapSockAddr;
import org.jnetpcap.packet.PcapPacket;
import org.jnetpcap.packet.PcapPacketHandler;

/**
 *
 * @author Diego EG
 */
public class GenerarTramas extends javax.swing.JFrame {

   
    private int nsecuencia;
    private int nacuse;
    private final int contienenombre; //Nunca enviaremos tramas a partir de un archivo
   
    public GenerarTramas() {
        initComponents();
        this.nsecuencia = 0;
        this.nacuse = 0;
        this.contienenombre = 0;
        DefaultListModel listaJList = new DefaultListModel();
        listaJList.addElement("Ningun paquete recibido");
        this.jlPaquetes.setModel(listaJList);
        this.jcbInterfaces.removeAllItems();
        mostrarDispositivos();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jlInstrucciones = new javax.swing.JLabel();
        jcbInterfaces = new javax.swing.JComboBox<>();
        jScrollPane1 = new javax.swing.JScrollPane();
        jlPaquetes = new javax.swing.JList<>();
        jbRegresar = new javax.swing.JButton();
        jbEnviar = new javax.swing.JButton();
        jlCadenaIngresada = new javax.swing.JLabel();
        jtfCadena = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jlInstrucciones.setText("Selecciona una interfaz para enviar las tramas");

        jcbInterfaces.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));

        jlPaquetes.setModel(new javax.swing.AbstractListModel<String>() {
            String[] strings = { "Item 1", "Item 2", "Item 3", "Item 4", "Item 5" };
            public int getSize() { return strings.length; }
            public String getElementAt(int i) { return strings[i]; }
        });
        jScrollPane1.setViewportView(jlPaquetes);

        jbRegresar.setText("Regresar");
        jbRegresar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbRegresarActionPerformed(evt);
            }
        });

        jbEnviar.setText("Enviar cadena");
        jbEnviar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbEnviarActionPerformed(evt);
            }
        });

        jlCadenaIngresada.setText("Ingresa una cadena a ser enviada ");

        jtfCadena.setText("Maximo 1024 caracteres");

        jLabel1.setText("Esta etiqueta sera sustituida pr una imagen con la forma de la trama");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 509, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addGap(77, 77, 77)
                                .addComponent(jbEnviar))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jlInstrucciones)
                                    .addComponent(jlCadenaIngresada))
                                .addGap(38, 38, 38)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(jcbInterfaces, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jtfCadena, javax.swing.GroupLayout.DEFAULT_SIZE, 203, Short.MAX_VALUE)))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jbRegresar)
                                .addGap(9, 9, 9))))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(35, 35, 35)
                        .addComponent(jLabel1)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jlInstrucciones)
                    .addComponent(jcbInterfaces, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 14, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jlCadenaIngresada)
                    .addComponent(jtfCadena, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 173, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jbEnviar)
                .addGap(2, 2, 2)
                .addComponent(jLabel1)
                .addGap(2, 2, 2)
                .addComponent(jbRegresar)
                .addGap(14, 14, 14))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jbRegresarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbRegresarActionPerformed
        Inicio formularioInicio = new Inicio();
        formularioInicio.setVisible(true);
        this.setVisible(false);
    }//GEN-LAST:event_jbRegresarActionPerformed

    private void jbEnviarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbEnviarActionPerformed
        PcapIf device = obtenerDireccionMacInterfazRed();
        byte trama [] = GenerarTrama(device);
        enviarTrama(trama);
    }//GEN-LAST:event_jbEnviarActionPerformed

    public List<PcapIf> obtenerListaDispositivos()
    {
        List<PcapIf> alldevs = new ArrayList<PcapIf>(); // Will be filled with NICs
		StringBuilder errbuf = new StringBuilder(); // For any error msgs

		/***************************************************************************
		 * First get a list of devices on this system
		 **************************************************************************/
		int r = Pcap.findAllDevs(alldevs, errbuf);
		if (r == Pcap.NOT_OK || alldevs.isEmpty()) {
			System.err.printf("Can't read list of devices, error is %s", errbuf
			    .toString());
			
		}
                
                return alldevs;

    }
    
    private static String asString(final byte[] mac) {
    final StringBuilder buf = new StringBuilder();
    for (byte b : mac) {
      if (buf.length() != 0) {
        buf.append(':');
      }
      if (b >= 0 && b < 16) {
        buf.append('0');
      }
      buf.append(Integer.toHexString((b < 0) ? b + 256 : b).toUpperCase());
    }

        return buf.toString();
    }
    
    public void mostrarDispositivos()
    {
        int i = 0;
        String informacion;
        byte[] MACo;
        List <PcapIf> dispositivos = obtenerListaDispositivos();
        
        this.jcbInterfaces.removeAllItems();
       
                try{
		for (PcapIf device : dispositivos) {
			String description =
			    (device.getDescription() != null) ? device.getDescription()
			        : "No description available";
                        final byte[] mac = device.getHardwareAddress();
			String dir_mac = (mac==null)?"No tiene direccion MAC":asString(mac);
                        i++;
                        informacion = "# "+i+" : "+device.getName()+ " [ "+description+" ] " +dir_mac;
                        this.jcbInterfaces.addItem(informacion);
                        //System.out.printf("#%d: %s [%s] MAC:[%s]\n", i++, device.getName(), description, dir_mac);

		}//for
                } catch (IOException ex) {
                    System.out.println("Excepcion atrapada -> "+ ex.getMessage());
        }
    }
    

    public PcapIf obtenerDireccionMacInterfazRed()
    {
        int i = this.jcbInterfaces.getSelectedIndex();
        List <PcapIf> dispositivos = obtenerListaDispositivos();
        PcapIf device = dispositivos.get(i);
        
        return device;
    }
    
    public byte[] GenerarTrama(PcapIf device)
    {
        byte trama[] = new byte[1052];
        String ip_interfaz ="";
        String mensaje = "";
        try {
            
            Iterator<PcapAddr> it1 = device.getAddresses().iterator();
            while(it1.hasNext()){
                PcapAddr dir = it1.next();//dir, familia, mascara,bc
                PcapSockAddr direccion1 =dir.getAddr();
                byte[]d_ip = direccion1.getData(); //esta sera la ip origen
                int familia=direccion1.getFamily();
                int[]ipv4_1 = new int[4];
                if(familia==org.jnetpcap.PcapSockAddr.AF_INET){
                    ipv4_1[0]=((int)d_ip[0]<0)?((int)d_ip[0])+256:(int)d_ip[0];
                    ipv4_1[1]=((int)d_ip[1]<0)?((int)d_ip[1])+256:(int)d_ip[1];
                    ipv4_1[2]=((int)d_ip[2]<0)?((int)d_ip[2])+256:(int)d_ip[2];
                    ipv4_1[3]=((int)d_ip[3]<0)?((int)d_ip[3])+256:(int)d_ip[3];
                    ip_interfaz = ipv4_1[0]+"."+ipv4_1[1]+"."+ipv4_1[2]+"."+ipv4_1[3];
                    System.out.println("\nInterfaz que se usara:"+ip_interfaz);
                }
            }
            /******************************************************/
            
            System.out.print("MAC ORIGEN: ");
            byte[] MACo = device.getHardwareAddress();
            for(int j=0;j<MACo.length;j++)
                System.out.printf("%02X ",MACo[j]);
            
         
            StringBuilder errbuf = new StringBuilder();
            int snaplen = 64 * 1024; // Capture all packets, no trucation  
            int flags = Pcap.MODE_PROMISCUOUS; // capture all packets  
            int timeout = 10 * 1000; // 10 seconds in millis  
            Pcap pcap = Pcap.openLive(device.getName(), snaplen, flags, timeout, errbuf); 
        
        
            for(int k=0;k<MACo.length;k++){
                trama[k] = (byte) 0xff;
                trama[k+6]=MACo[k];
            }//for
            
            Random random = new Random();
            int region = random.nextInt(254);
            String ip[] = ip_interfaz.split("\\."); //El punto "." se usa en las expresiones regulares por lo que se se quiere referir a el se debe definir como "\\."
     
            trama[12]= (byte) 0x16; //tipo sin asignar
            trama[13]= (byte) 0x01; //tipo sin asignar rfc 1340 
            trama[14] = (byte) 144; //Version
            trama[15] = (byte) this.contienenombre; 
    
            trama[16] = (byte) this.nsecuencia++; //Secuencia
            trama[17] = (byte) this.nacuse++; //Acuse
            trama[18] = (byte) (random.nextInt(250)+5);
            trama[19] = (byte) (random.nextInt(9));
            trama[20] = (byte) (random.nextInt(30)+2);
            trama[21] = (byte) (random.nextInt(10)+1);
            trama[22] = (byte) Integer.parseInt(ip[0]);
            trama[23] = (byte) Integer.parseInt(ip[1]);
            trama[24] = (byte) Integer.parseInt(ip[2]);
            trama[25] = (byte) Integer.parseInt(ip[3]);
        
           mensaje = this.jtfCadena.getText();
           
           byte[]buf = mensaje.getBytes();
           int tam = buf.length;
           if(tam<1024){
                        for(int c=0;c<tam;c++)
                            trama[26+c]=buf[c]; //El mensaje se guarda en las posiciones correespondientes al maensaje en la trama a partir de la posicion 30
           }else{
                 System.out.println("El mensaje es muy largo.Maximo 1024 bytes");
            System.exit(1);
           }
           
            int pos=0;
            byte checksum[] = new byte[1036];
            for (int j = 14; j < 1050; j++) { // 14, donde comienza el protocolo y 1049 en donde se encuentran los valores para el protocolo
                checksum[pos] = trama[j];
                pos++;
            }
            long ch = Checksum.calculateChecksum(checksum);
            long temp = ch;
            trama[1051] = (byte) ch;
            temp = temp>>8;
            trama[1050] = (byte)  temp;
            
        }
         catch (IOException ex) {
            System.out.println("Excepcion atrapada-> "+ex.getMessage() ); //JOPTION
        }
       
        /*
        System.out.println("Enviare la trama:");
        
        
        for (int i = 0; i < 1052; i++) {
            System.out.printf("%02X ",trama[i]);
             if(i%16==15)
                System.out.println("");
        }
        */
    
        return trama;
    }
    
    public void enviarTrama(byte trama[])    
    {
        //List<PcapIf> dispositivos = obtenerListaDispositivos();
        PcapIf device = obtenerDireccionMacInterfazRed();
        ByteBuffer b = ByteBuffer.wrap(trama);  
        StringBuilder errbuf = new StringBuilder();
  
        int snaplen = 64 * 1024; // Capture all packets, no trucation  
        int flags = Pcap.MODE_PROMISCUOUS; // capture all packets  
        int timeout = 10 * 1000; // 10 seconds in millis  
        Pcap pcap = Pcap.openLive(device.getName(), snaplen, flags, timeout, errbuf); 
  
    
    
    /********F I L T R O********/
            PcapBpfProgram filter = new PcapBpfProgram();
            String expression ="ether proto 0x1601"; // "port 80";
            int optimize = 0; // 1 means true, 0 means false
            int netmask = 0;
            int r2 = pcap.compile(filter, expression, optimize, netmask);
            if (r2 != Pcap.OK) {
                System.out.println("Filter error: " + pcap.getErr());
            }//if
            pcap.setFilter(filter);
            
            PcapPacketHandler<String> jpacketHandler = new PcapPacketHandler<String>() {

			
        public void nextPacket(PcapPacket packet, String user) {

				System.out.printf("Paquete recibido el %s bytes capturados=%-4d tam original=%-4d %s\n",
				    new Date(packet.getCaptureHeader().timestampInMillis()),
				    packet.getCaptureHeader().caplen(),  // Length actually captured
				    packet.getCaptureHeader().wirelen(), // Original length
				    user                                 // User supplied object
				    );
                                /******Desencapsulado********/
                                System.out.println("MAC destino:");
                                for(int i=0;i<6;i++){
                                System.out.printf("%02X ",packet.getUByte(i));
                                }
                                System.out.println("");
                                System.out.println("MAC origen:");
                                for(int i=6;i<12;i++){
                                System.out.printf("%02X ",packet.getUByte(i));
                                }
                                System.out.println("");
                                System.out.println("Tipo:");
                                for(int i=12;i<14;i++){
                                System.out.printf("%02X ",packet.getUByte(i));
                                }
                                int tipo = (packet.getUByte(12)*256)+packet.getUByte(13);
                                System.out.printf("Tipo= %d",tipo);
                                System.out.printf("\nVersion: %02X",packet.getUByte(14));
                                System.out.printf("\nNombre del archivo: %02X",packet.getUByte(15));
                                System.out.printf("\nNum. Secuencia: %02X",packet.getUByte(16));
                                System.out.printf("\nNum. Acuse : %02X",packet.getUByte(17));
System.out.printf("\nIp destino: %d.%d.%d.%d",packet.getUByte(18),packet.getUByte(19),packet.getUByte(20),packet.getUByte(21));
System.out.printf("\nIp origen: %d.%d.%d.%d",packet.getUByte(22),packet.getUByte(23),packet.getUByte(24),packet.getUByte(25));
                                if(tipo==5633){ //0x1601
                                   System.out.println("\nMensaje enviado:");
                                   byte[]t = packet.getByteArray(26, 1024); //???????El segundo parametro es la cantidad de bytes que va a leer la funcion, no la posicion donde termina 
                                   for(int k=0;k<t.length;k++)
                                       System.out.printf("%02X ",t[k]);
                                       String datos = new String(t);
                                    System.out.println("\nEl mensaje es: "+datos);
                                    System.out.println("Checksum:");
                                //for(int i=12;i<14;i++){
                                System.out.printf("%02X %02X",packet.getUByte(1050),packet.getUByte(1051));
                                //}
                                System.out.println("");
                                for(int l=0;l<packet.size();l++){
                                System.out.printf("%02X ",packet.getUByte(l));
                                if(l%16==15)
                                    System.out.println("");
                                }

                                
                                }//if
                                
                                //System.out.println("\n\nEncabezado: "+ packet.toHexdump());
      
                                System.out.println("");
			}
		};
            
            if (pcap.sendPacket(trama) != Pcap.OK) {  
                System.err.println(pcap.getErr());  
            }
            else
            System.out.println("***Envie un paquete***");
             try{
            Thread.sleep(500);
        }catch(InterruptedException e){}
       
        pcap.loop(1, jpacketHandler, "");
        
       
    /******************************************************** 
     * Lastly we close 
     ********************************************************/  
    pcap.close();  
            
            
            
        
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JButton jbEnviar;
    private javax.swing.JButton jbRegresar;
    private javax.swing.JComboBox<String> jcbInterfaces;
    private javax.swing.JLabel jlCadenaIngresada;
    private javax.swing.JLabel jlInstrucciones;
    private javax.swing.JList<String> jlPaquetes;
    private javax.swing.JTextField jtfCadena;
    // End of variables declaration//GEN-END:variables
}
